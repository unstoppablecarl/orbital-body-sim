<!DOCTYPE html>
<html>
<head>
  <title>p2-es Destructible Body Demo (Single File)</title>
  <style>
      body { margin: 0; background-color: #f0f0f0; }
      canvas { display: block; background-color: #fff; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script type="module">
  // Import p2-es from a CDN
  import * as p2 from 'https://www.unpkg.com/p2-es/dist/p2-es.js';

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let world;
  const bodies = [];
  const constraints = [];

  // Physics settings
  const fixedTimeStep = 1 / 60;
  const maxSubSteps = 10;
  let lastTime;

  // Renderer settings
  const RENDERER_SCALE = 15;
  const COLORS = {
    STATIC: '#666',
    DYNAMIC: '#007bff',
    IMPACT: '#ffc107'
  };

  function setupWorld() {
    world = new p2.World({
      gravity: [0, -9.82]
    });

    // Add a ground plane
    const groundBody = new p2.Body({ mass: 0 });
    const groundShape = new p2.Plane();
    groundBody.addShape(groundShape);
    world.addBody(groundBody);

    createDestructibleBlock(0, 5);
    createProjectile(-10, 4);

    world.on('beginContact', (event) => {
      const { shapeA, shapeB, impactVelocity } = event;
      // Check for impact with significant force
      const forceThreshold = 5;
      if (impactVelocity > forceThreshold) {
        checkAndBreakConstraints(shapeA.body, impactVelocity);
        checkAndBreakConstraints(shapeB.body, impactVelocity);
      }
    });
  }

  function createDestructibleBlock(x, y) {
    const squareSize = 0.5;
    const spacing = squareSize * 1.05;
    const rows = 4;
    const cols = 4;
    const blockBodies = [];

    // Create a grid of smaller square bodies
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const body = new p2.Body({
          mass: 1,
          position: [x + j * spacing - (cols * spacing) / 2, y + i * spacing]
        });
        body.addShape(new p2.Box({ width: squareSize, height: squareSize }));
        world.addBody(body);
        bodies.push(body);
        blockBodies.push(body);
      }
    }

    // Connect bodies with constraints (joints)
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const currentBody = blockBodies[i * cols + j];

        // Connect to the right
        if (j < cols - 1) {
          const rightBody = blockBodies[i * cols + j + 1];
          const constraint = new p2.DistanceConstraint(currentBody, rightBody);
          world.addConstraint(constraint);
          constraints.push(constraint);
        }

        // Connect to the top
        if (i < rows - 1) {
          const topBody = blockBodies[(i + 1) * cols + j];
          const constraint = new p2.DistanceConstraint(currentBody, topBody);
          world.addConstraint(constraint);
          constraints.push(constraint);
        }
      }
    }
  }

  function createProjectile(x, y) {
    const projectileBody = new p2.Body({
      mass: 5,
      position: [x, y],
      velocity: [30, 5] // Give it an initial push
    });
    projectileBody.addShape(new p2.Circle({ radius: 0.75 }));
    world.addBody(projectileBody);
    bodies.push(projectileBody);
  }

  function checkAndBreakConstraints(body, impactVelocity) {
    // This function checks the body involved in a collision and removes its constraints
    for (let i = constraints.length - 1; i >= 0; i--) {
      const constraint = constraints[i];
      if (constraint.bodyA === body || constraint.bodyB === body) {
        if (impactVelocity > 5) { // A threshold to prevent breaking on every minor bump
          world.removeConstraint(constraint);
          constraints.splice(i, 1);
        }
      }
    }
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set up camera transformation
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(RENDERER_SCALE, -RENDERER_SCALE);

    // Draw ground
    ctx.strokeStyle = COLORS.STATIC;
    ctx.lineWidth = 0.1;
    ctx.beginPath();
    ctx.moveTo(-canvas.width / RENDERER_SCALE / 2, 0);
    ctx.lineTo(canvas.width / RENDERER_SCALE / 2, 0);
    ctx.stroke();

    // Draw bodies
    bodies.forEach(body => {
      body.shapes.forEach(shape => {
        ctx.fillStyle = COLORS.DYNAMIC;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.05;

        ctx.beginPath();
        if (shape instanceof p2.Box) {
          const w = shape.width;
          const h = shape.height;
          ctx.save();
          ctx.translate(body.position[0], body.position[1]);
          ctx.rotate(body.angle);
          ctx.fillRect(-w/2, -h/2, w, h);
          ctx.strokeRect(-w/2, -h/2, w, h);
          ctx.restore();
        } else if (shape instanceof p2.Circle) {
          ctx.beginPath();
          ctx.save();
          ctx.translate(body.position[0], body.position[1]);
          ctx.arc(0, 0, shape.radius, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      });
    });

    // Draw constraints
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 0.02;
    constraints.forEach(c => {
      const bodyA = c.bodyA;
      const bodyB = c.bodyB;
      ctx.beginPath();
      ctx.moveTo(bodyA.position[0], bodyA.position[1]);
      ctx.lineTo(bodyB.position[0], bodyB.position[1]);
      ctx.stroke();
    });

    ctx.restore();
  }

  function animate(time) {
    requestAnimationFrame(animate);

    // Get elapsed time since last frame
    const deltaTime = lastTime ? (time - lastTime) / 1000 : 0;

    // Step the physics world
    world.step(fixedTimeStep, deltaTime, maxSubSteps);

    // Render the scene
    render();

    lastTime = time;
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  setupWorld();
  animate();
</script>
</body>
</html>
